"use strict";(globalThis.webpackChunkhumanoid_robotics=globalThis.webpackChunkhumanoid_robotics||[]).push([[949],{3760:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"Locomotion-and-Control/Principles-of-Bipedal-Locomotion","title":"Principles of Bipedal Locomotion","description":"Overview","source":"@site/docs/Locomotion-and-Control/01-Principles-of-Bipedal-Locomotion.md","sourceDirName":"Locomotion-and-Control","slug":"/Locomotion-and-Control/Principles-of-Bipedal-Locomotion","permalink":"/textbook.github.io/docs/Locomotion-and-Control/Principles-of-Bipedal-Locomotion","draft":false,"unlisted":false,"editUrl":"https://github.com/Mohammed-Umair-Kalim/textbook.github.io/docs/Locomotion-and-Control/01-Principles-of-Bipedal-Locomotion.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Chapter Plan: Locomotion and Control","permalink":"/textbook.github.io/docs/Locomotion-and-Control/plan"},"next":{"title":"Advanced Control Strategies","permalink":"/textbook.github.io/docs/Locomotion-and-Control/Advanced-Control-Strategies"}}');var i=o(4848),s=o(8453);const a={sidebar_position:1},r="Principles of Bipedal Locomotion",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Detailed Explanation",id:"detailed-explanation",level:2},{value:"The Zero Moment Point (ZMP)",id:"the-zero-moment-point-zmp",level:3},{value:"The Linear Inverted Pendulum Model (LIPM)",id:"the-linear-inverted-pendulum-model-lipm",level:3},{value:"Hands-on Exercise: Simulating a Linear Inverted Pendulum",id:"hands-on-exercise-simulating-a-linear-inverted-pendulum",level:2},{value:"The Scenario",id:"the-scenario",level:3},{value:"The Code",id:"the-code",level:3},{value:"How it Works",id:"how-it-works",level:3},{value:"Experiment",id:"experiment",level:3},{value:"Case Study: Boston Dynamics&#39; Atlas - A Leap in Dynamic Balancing",id:"case-study-boston-dynamics-atlas---a-leap-in-dynamic-balancing",level:2}];function h(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"principles-of-bipedal-locomotion",children:"Principles of Bipedal Locomotion"})}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"Bipedal locomotion, or walking on two legs, is one of the defining characteristics of a humanoid robot. It is also one of the most difficult challenges in robotics. This section introduces two of the most important concepts in bipedal locomotion: the Zero Moment Point (ZMP) and the Linear Inverted Pendulum Model (LIPM)."}),"\n",(0,i.jsx)(t.h2,{id:"detailed-explanation",children:"Detailed Explanation"}),"\n",(0,i.jsx)(t.h3,{id:"the-zero-moment-point-zmp",children:"The Zero Moment Point (ZMP)"}),"\n",(0,i.jsx)(t.p,{children:"The Zero Moment Point (ZMP) is a concept that was first introduced by Miomir Vukobratovi\u0107 in the early 1970s. It is defined as the point on the ground where the net moment of the inertial forces and the gravity forces has no component along the horizontal axes. In simpler terms, the ZMP is the point on the ground where the total tipping moment acting on the robot is zero."}),"\n",(0,i.jsxs)(t.p,{children:["For the robot to be stable, the ZMP must always remain within the ",(0,i.jsx)(t.strong,{children:"support polygon"}),". The support polygon is the area on the ground that is formed by the convex hull of all the points where the robot is in contact with the ground. For a robot standing on one foot, the support polygon is the area of the foot. For a robot standing on two feet, the support polygon is the area that includes both feet and the space between them."]}),"\n",(0,i.jsx)(t.p,{children:"By controlling the ZMP, it is possible to control the stability of the robot. Most modern bipedal robots use some form of ZMP-based control to generate their walking patterns. The basic idea is to first plan a desired trajectory for the ZMP, and then use a control system to move the robot's body in such a way that the actual ZMP tracks the desired ZMP."}),"\n",(0,i.jsx)(t.h3,{id:"the-linear-inverted-pendulum-model-lipm",children:"The Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,i.jsx)(t.p,{children:"The Linear Inverted Pendulum Model (LIPM) is a simplified model of a bipedal robot that is often used for walking pattern generation. In this model, the entire mass of the robot is assumed to be concentrated at a single point (the center of mass), and the legs are assumed to be massless. The robot is modeled as a point mass on top of a rigid rod, which is free to pivot about a point on the ground."}),"\n",(0,i.jsx)(t.p,{children:"The dynamics of the LIPM are much simpler than the dynamics of a full humanoid robot, which makes it possible to generate walking patterns in real-time. The basic idea is to control the position of the center of mass in such a way that the ZMP remains within the support polygon."}),"\n",(0,i.jsx)(t.p,{children:"By combining the LIPM with ZMP-based control, it is possible to generate smooth and stable walking patterns for a humanoid robot. This approach has been used successfully in many famous humanoid robots, including Honda's ASIMO and Boston Dynamics' Atlas."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"hands-on-exercise-simulating-a-linear-inverted-pendulum",children:"Hands-on Exercise: Simulating a Linear Inverted Pendulum"}),"\n",(0,i.jsx)(t.p,{children:"This exercise will guide you through writing a Python script to simulate the motion of a Linear Inverted Pendulum (LIPM)."}),"\n",(0,i.jsx)(t.h3,{id:"the-scenario",children:"The Scenario"}),"\n",(0,i.jsxs)(t.p,{children:["You have a point mass ",(0,i.jsx)(t.code,{children:"m"})," at a height ",(0,i.jsx)(t.code,{children:"h"}),". The position of the point mass is ",(0,i.jsx)(t.code,{children:"(x, y, h)"}),". The position of the pivot point on the ground is ",(0,i.jsx)(t.code,{children:"(px, py)"}),". The dynamics of the LIPM are given by the following equations:"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"x_ddot = (g / h) * (x - px)"}),"\n",(0,i.jsx)(t.code,{children:"y_ddot = (g / h) * (y - py)"})]}),"\n",(0,i.jsxs)(t.p,{children:["where ",(0,i.jsx)(t.code,{children:"g"})," is the acceleration due to gravity."]}),"\n",(0,i.jsxs)(t.p,{children:["Your task is to write a function that takes the current state of the pendulum ",(0,i.jsx)(t.code,{children:"(x, y, x_dot, y_dot)"})," and the position of the pivot ",(0,i.jsx)(t.code,{children:"(px, py)"})," as input, and returns the accelerations ",(0,i.jsx)(t.code,{children:"(x_ddot, y_ddot)"}),". You will then use this function to simulate the motion of the pendulum over time."]}),"\n",(0,i.jsx)(t.h3,{id:"the-code",children:"The Code"}),"\n",(0,i.jsx)(t.p,{children:"This Python script simulates the LIPM."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:'import matplotlib.pyplot as plt\n\ndef lipm_dynamics(state, pivot, g, h):\n    """\n    Calculates the accelerations of the LIPM.\n\n    Args:\n        state: A tuple (x, y, x_dot, y_dot) representing the current state of the pendulum.\n        pivot: A tuple (px, py) representing the position of the pivot.\n        g: The acceleration due to gravity.\n        h: The height of the center of mass.\n\n    Returns:\n        A tuple (x_ddot, y_ddot) representing the accelerations of the pendulum.\n    """\n    x, y, _, _ = state\n    px, py = pivot\n    x_ddot = (g / h) * (x - px)\n    y_ddot = (g / h) * (y - py)\n    return (x_ddot, y_ddot)\n\ndef simulate_lipm(initial_state, pivot, g, h, dt, num_steps):\n    """\n    Simulates the motion of the LIPM over time.\n\n    Args:\n        initial_state: The initial state of the pendulum.\n        pivot: The position of the pivot.\n        g: The acceleration due to gravity.\n        h: The height of the center of mass.\n        dt: The time step for the simulation.\n        num_steps: The number of steps to simulate.\n\n    Returns:\n        A list of states representing the trajectory of the pendulum.\n    """\n    states = [initial_state]\n    for _ in range(num_steps):\n        current_state = states[-1]\n        x, y, x_dot, y_dot = current_state\n        x_ddot, y_ddot = lipm_dynamics(current_state, pivot, g, h)\n        x_dot += x_ddot * dt\n        y_dot += y_ddot * dt\n        x += x_dot * dt\n        y += y_dot * dt\n        states.append((x, y, x_dot, y_dot))\n    return states\n\nif __name__ == \'__main__\':\n    # Simulation parameters\n    initial_state = (0.0, 0.0, 0.5, 0.0)  # (x, y, x_dot, y_dot)\n    pivot = (0.1, 0.0)\n    g = 9.81\n    h = 1.0\n    dt = 0.01\n    num_steps = 200\n\n    # Simulate the LIPM\n    trajectory = simulate_lipm(initial_state, pivot, g, h, dt, num_steps)\n\n    # Plot the results\n    x_traj = [state[0] for state in trajectory]\n    y_traj = [state[1] for state in trajectory]\n    plt.plot(x_traj, y_traj)\n    plt.xlabel("x (m)")\n    plt.ylabel("y (m)")\n    plt.title("Trajectory of a Linear Inverted Pendulum")\n    plt.grid(True)\n    plt.axis(\'equal\')\n    plt.show()\n'})}),"\n",(0,i.jsx)(t.h3,{id:"how-it-works",children:"How it Works"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"lipm_dynamics"})," function implements the equations of motion for the LIPM."]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"simulate_lipm"})," function uses Euler integration to simulate the motion of the pendulum over time."]}),"\n",(0,i.jsx)(t.li,{children:"The main part of the script sets up the simulation parameters, runs the simulation, and plots the results."}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"experiment",children:"Experiment"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Run the script and observe the trajectory of the pendulum."}),"\n",(0,i.jsx)(t.li,{children:"Try changing the initial state of the pendulum and the position of the pivot and see how the trajectory changes."}),"\n",(0,i.jsx)(t.li,{children:"Can you modify the script to simulate walking by changing the position of the pivot at each step?"}),"\n"]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"case-study-boston-dynamics-atlas---a-leap-in-dynamic-balancing",children:"Case Study: Boston Dynamics' Atlas - A Leap in Dynamic Balancing"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Introduction:"}),"\nBoston Dynamics' Atlas is arguably the most advanced humanoid robot in the world. It is capable of a wide range of dynamic behaviors, including running, jumping, and even performing backflips. This case study examines some of the key control strategies that enable Atlas's remarkable agility."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Beyond ZMP:"}),"\nWhile ZMP-based control is effective for generating stable walking patterns on flat terrain, it is not well-suited for more dynamic behaviors like running and jumping. This is because the ZMP is only defined when the robot is in contact with the ground. During the flight phase of running or jumping, the ZMP is undefined."]}),"\n",(0,i.jsx)(t.p,{children:"To overcome this limitation, Boston Dynamics has developed a more advanced control strategy that is based on a whole-body control approach. This approach considers the full dynamics of the robot and allows for more aggressive and dynamic movements."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Model Predictive Control (MPC):"}),"\nAt the heart of Atlas's control system is a form of Model Predictive Control (MPC). MPC is an advanced control strategy that uses a model of the robot to predict its future behavior. The controller then optimizes the robot's control inputs (i.e., the joint torques) over a short time horizon to achieve a desired goal, such as tracking a desired trajectory or maintaining balance."]}),"\n",(0,i.jsx)(t.p,{children:"One of the key advantages of MPC is that it can handle constraints, such as the limits on joint torques and the need to keep the robot's feet on the ground. This makes it well-suited for controlling a complex system like a humanoid robot."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"A Hierarchical Approach:"}),"\nAtlas's control system is organized in a hierarchical manner."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"High-level planner:"})," A high-level planner is used to generate a rough plan for the robot's behavior, such as a sequence of footsteps to navigate a complex terrain."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Mid-level controller:"})," A mid-level controller, based on MPC, is used to refine the plan and generate a smooth and dynamically feasible trajectory for the robot's center of mass."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Low-level controller:"})," A low-level controller is used to calculate the joint torques required to track the desired trajectory."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Legacy:"}),"\nAtlas has pushed the boundaries of what is possible in humanoid robotics. It has demonstrated that it is possible to build a bipedal robot that is not only stable but also agile and robust. The control strategies developed for Atlas are now being used in a wide range of other robotic systems, and they are likely to play a key role in the development of the next generation of humanoid robots."]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>a,x:()=>r});var n=o(6540);const i={},s=n.createContext(i);function a(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);