"use strict";(globalThis.webpackChunkhumanoid_robotics=globalThis.webpackChunkhumanoid_robotics||[]).push([[461],{3055:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Humanoid-Robotics-Hardware-and-Morphology/Kinematics-and-Dynamics-The-Science-of-Motion","title":"Kinematics and Dynamics: The Science of Motion","description":"Overview","source":"@site/docs/Humanoid-Robotics-Hardware-and-Morphology/02-Kinematics-and-Dynamics-The-Science-of-Motion.md","sourceDirName":"Humanoid-Robotics-Hardware-and-Morphology","slug":"/Humanoid-Robotics-Hardware-and-Morphology/Kinematics-and-Dynamics-The-Science-of-Motion","permalink":"/textbook.github.io/docs/Humanoid-Robotics-Hardware-and-Morphology/Kinematics-and-Dynamics-The-Science-of-Motion","draft":false,"unlisted":false,"editUrl":"https://github.com/Mohammed-Umair-Kalim/textbook.github.io/docs/Humanoid-Robotics-Hardware-and-Morphology/02-Kinematics-and-Dynamics-The-Science-of-Motion.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Actuators and Sensors: The Building Blocks of Movement","permalink":"/textbook.github.io/docs/Humanoid-Robotics-Hardware-and-Morphology/Actuators-and-Sensors-The-Building-Blocks-of-Movement"},"next":{"title":"Power Systems and Energy Efficiency","permalink":"/textbook.github.io/docs/Humanoid-Robotics-Hardware-and-Morphology/Power-Systems-and-Energy-Efficiency"}}');var o=t(4848),s=t(8453);const r={sidebar_position:2},a="Kinematics and Dynamics: The Science of Motion",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Detailed Explanation",id:"detailed-explanation",level:2},{value:"Kinematics: The Geometry of Motion",id:"kinematics-the-geometry-of-motion",level:3},{value:"Degrees of Freedom (DOF)",id:"degrees-of-freedom-dof",level:4},{value:"Forward Kinematics",id:"forward-kinematics",level:4},{value:"Inverse Kinematics",id:"inverse-kinematics",level:4},{value:"Dynamics: The Physics of Motion",id:"dynamics-the-physics-of-motion",level:3},{value:"Equations of Motion",id:"equations-of-motion",level:4},{value:"Hands-on Exercise: Forward Kinematics of a 2-Link Arm",id:"hands-on-exercise-forward-kinematics-of-a-2-link-arm",level:2},{value:"The Scenario",id:"the-scenario",level:3},{value:"The Code",id:"the-code",level:3},{value:"How it Works",id:"how-it-works",level:3},{value:"Experiment",id:"experiment",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"kinematics-and-dynamics-the-science-of-motion",children:"Kinematics and Dynamics: The Science of Motion"})}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(n.p,{children:"Kinematics and dynamics are two of the most fundamental concepts in robotics. Kinematics is the study of motion without considering the forces that cause it, while dynamics is the study of motion in relation to the forces and torques that produce it. A solid understanding of both is essential for designing, controlling, and simulating humanoid robots. This section will introduce the key concepts of kinematics and dynamics as they apply to robotics."}),"\n",(0,o.jsx)(n.h2,{id:"detailed-explanation",children:"Detailed Explanation"}),"\n",(0,o.jsx)(n.h3,{id:"kinematics-the-geometry-of-motion",children:"Kinematics: The Geometry of Motion"}),"\n",(0,o.jsx)(n.p,{children:"Kinematics is concerned with the geometry of motion. In robotics, we are often interested in the relationship between the angles of a robot's joints and the position and orientation of its end-effector (e.g., its hand or foot)."}),"\n",(0,o.jsx)(n.h4,{id:"degrees-of-freedom-dof",children:"Degrees of Freedom (DOF)"}),"\n",(0,o.jsx)(n.p,{children:"The number of degrees of freedom of a robot is the number of independent parameters that are required to completely specify its configuration. For a simple robotic arm, the number of degrees of freedom is typically equal to the number of joints. A human arm has 7 degrees of freedom, which is why it is so agile and dexterous."}),"\n",(0,o.jsx)(n.h4,{id:"forward-kinematics",children:"Forward Kinematics"}),"\n",(0,o.jsx)(n.p,{children:"Forward kinematics is the problem of finding the position and orientation of the end-effector given the angles of all the joints. This is a relatively easy problem to solve. For a simple 2D robotic arm with two joints, the position of the end-effector can be found using basic trigonometry:"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"x = L1 * cos(theta1) + L2 * cos(theta1 + theta2)"}),"\n",(0,o.jsx)(n.code,{children:"y = L1 * sin(theta1) + L2 * sin(theta1 + theta2)"})]}),"\n",(0,o.jsxs)(n.p,{children:["where ",(0,o.jsx)(n.code,{children:"L1"})," and ",(0,o.jsx)(n.code,{children:"L2"})," are the lengths of the two links, and ",(0,o.jsx)(n.code,{children:"theta1"})," and ",(0,o.jsx)(n.code,{children:"theta2"})," are the angles of the two joints."]}),"\n",(0,o.jsx)(n.h4,{id:"inverse-kinematics",children:"Inverse Kinematics"}),"\n",(0,o.jsx)(n.p,{children:"Inverse kinematics is the reverse problem: finding the required joint angles to place the end-effector at a desired position and orientation. This is a much more difficult problem to solve, as there may be multiple solutions or no solution at all. For complex robots with many degrees of freedom, finding a solution to the inverse kinematics problem often requires iterative numerical methods."}),"\n",(0,o.jsx)(n.h3,{id:"dynamics-the-physics-of-motion",children:"Dynamics: The Physics of Motion"}),"\n",(0,o.jsx)(n.p,{children:"Dynamics is concerned with the relationship between motion and the forces and torques that cause it. In robotics, we are often interested in calculating the torques required at each joint to produce a desired motion of the robot."}),"\n",(0,o.jsx)(n.h4,{id:"equations-of-motion",children:"Equations of Motion"}),"\n",(0,o.jsx)(n.p,{children:"The equations of motion describe how the robot will move in response to the forces and torques applied to it. These equations are derived from the principles of Newtonian mechanics and can be quite complex for a multi-link robot. The general form of the equations of motion for a robot is:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"T = M(q) * q_ddot + C(q, q_dot) * q_dot + G(q)"})}),"\n",(0,o.jsx)(n.p,{children:"where:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"T"})," is the vector of joint torques."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"q"}),", ",(0,o.jsx)(n.code,{children:"q_dot"}),", and ",(0,o.jsx)(n.code,{children:"q_ddot"})," are the vectors of joint positions, velocities, and accelerations, respectively."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"M(q)"})," is the mass matrix, which relates the joint accelerations to the joint torques."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"C(q, q_dot)"})," is the Coriolis and centrifugal matrix, which accounts for the forces that arise from the interaction between the moving links."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"G(q)"})," is the gravity vector, which accounts for the torques caused by gravity."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"A solid understanding of robot dynamics is essential for designing control systems that can accurately and stably control the motion of the robot."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"hands-on-exercise-forward-kinematics-of-a-2-link-arm",children:"Hands-on Exercise: Forward Kinematics of a 2-Link Arm"}),"\n",(0,o.jsx)(n.p,{children:"This exercise will guide you through writing a Python script to calculate the forward kinematics of a simple 2-link robotic arm in 2D."}),"\n",(0,o.jsx)(n.h3,{id:"the-scenario",children:"The Scenario"}),"\n",(0,o.jsxs)(n.p,{children:["You have a robotic arm with two links of length ",(0,o.jsx)(n.code,{children:"L1"})," and ",(0,o.jsx)(n.code,{children:"L2"}),". The first joint (",(0,o.jsx)(n.code,{children:"theta1"}),") is the angle of the first link with respect to the horizontal axis, and the second joint (",(0,o.jsx)(n.code,{children:"theta2"}),") is the angle of the second link with respect to the first link."]}),"\n",(0,o.jsxs)(n.p,{children:["Your task is to write a function that takes ",(0,o.jsx)(n.code,{children:"L1"}),", ",(0,o.jsx)(n.code,{children:"L2"}),", ",(0,o.jsx)(n.code,{children:"theta1"}),", and ",(0,o.jsx)(n.code,{children:"theta2"})," as input and returns the ",(0,o.jsx)(n.code,{children:"(x, y)"})," position of the end-effector."]}),"\n",(0,o.jsx)(n.h3,{id:"the-code",children:"The Code"}),"\n",(0,o.jsx)(n.p,{children:"This Python script calculates the forward kinematics."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import math\n\ndef forward_kinematics(L1, L2, theta1, theta2):\n    """\n    Calculates the (x, y) position of the end-effector of a 2-link robotic arm.\n\n    Args:\n        L1: Length of the first link.\n        L2: Length of the second link.\n        theta1: Angle of the first joint in degrees.\n        theta2: Angle of the second joint in degrees.\n\n    Returns:\n        A tuple (x, y) representing the position of the end-effector.\n    """\n    # Convert angles from degrees to radians\n    theta1_rad = math.radians(theta1)\n    theta2_rad = math.radians(theta2)\n\n    # Calculate the position of the end-effector\n    x = L1 * math.cos(theta1_rad) + L2 * math.cos(theta1_rad + theta2_rad)\n    y = L1 * math.sin(theta1_rad) + L2 * math.sin(theta1_rad + theta2_rad)\n\n    return (x, y)\n\nif __name__ == \'__main__\':\n    # Example usage\n    L1 = 10.0\n    L2 = 8.0\n    theta1 = 45.0\n    theta2 = 30.0\n\n    x, y = forward_kinematics(L1, L2, theta1, theta2)\n    print(f"The position of the end-effector is ({x:.2f}, {y:.2f})")\n\n    # Example with different angles\n    theta1 = 90.0\n    theta2 = -90.0\n    x, y = forward_kinematics(L1, L2, theta1, theta2)\n    print(f"The position of the end-effector is ({x:.2f}, {y:.2f})")\n\n'})}),"\n",(0,o.jsx)(n.h3,{id:"how-it-works",children:"How it Works"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"forward_kinematics"})," function takes the link lengths and joint angles as input."]}),"\n",(0,o.jsxs)(n.li,{children:["It first converts the angles from degrees to radians, as the trigonometric functions in Python's ",(0,o.jsx)(n.code,{children:"math"})," module expect radians."]}),"\n",(0,o.jsxs)(n.li,{children:["It then applies the forward kinematics equations to calculate the ",(0,o.jsx)(n.code,{children:"x"})," and ",(0,o.jsx)(n.code,{children:"y"})," coordinates of the end-effector."]}),"\n",(0,o.jsx)(n.li,{children:"The main part of the script shows how to use the function with some example values."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"experiment",children:"Experiment"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Run the script and verify that the output is correct."}),"\n",(0,o.jsx)(n.li,{children:"Try different values for the link lengths and joint angles and see how the position of the end-effector changes."}),"\n",(0,o.jsx)(n.li,{children:'Can you modify the function to also return the position of the "elbow" joint (the joint between the two links)?'}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);